"""
Copyright Â© 2024 Fabian H. Schneider

This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
If a copy of the MPL was not distributed with this file,
You can obtain one at https://mozilla.org/MPL/2.0/.
"""

__doc__ = """\
Rough version generated by Claude 3.5 Sonnet (New) on 2024-10-27; then manually edited.
"""

from pathlib import Path
from typing import Any


class JsonSchemaMarkdownGenerator:
    """
    Generates Markdown documentation from a JSONSchema.
    """

    def __init__(self, indent_size: int = 2):
        """
        :param indent_size: Number of spaces to use for indentation
        """
        self.indent_size = indent_size
        self.current_heading_level = 1

    def generate_markdown(self, schema: dict[str, Any], title: str | None = None) -> str:
        """
        Generate Markdown documentation from a JSONSchema.

        :param schema: The JSONSchema dictionary
        :param title: Optional title for the documentation

        Returns:
            str: Generated Markdown documentation
        """
        sections: list[str] = []

        # Add title if provided
        if title:
            sections.append(f"# {title}\n")
        elif schema.get("title"):
            sections.append(f"# {schema["title"]}\n")

        # Add description if available
        if schema.get("description"):
            sections.append(f"{schema["description"]}\n")

        # Process the root schema
        sections.append(self._process_schema(schema))

        return "\n".join(sections)

    def _process_schema(self, schema: dict[str, Any], name: str = "", required: bool = False) -> str:
        """
        Process a schema object and return its Markdown representation.

        :param schema: The schema
        :param name: Optional name of the schema
        :param required: Whether the schema is required
        :return: Markdown documentation for the schema
        """
        sections: list[str] = []

        # Handle different types of schemas
        match schema:
            case _ if "anyOf" in schema:
                return self._process_schema_combination(schema["anyOf"], "anyOf", name, required)
            case _ if "oneOf" in schema:
                return self._process_schema_combination(schema["oneOf"], "oneOf", name, required)
            case _ if "allOf" in schema:
                return self._process_schema_combination(schema["allOf"], "allOf", name, required)
        if schema.get("type") == "object":
            sections.append(self._process_object(schema, name, required))
        elif schema.get("type") == "array":
            sections.append(self._process_array(schema, name, required))
        else:
            sections.append(self._process_primitive(schema, name, required))

        return "\n".join(sections)

    def _process_object(self, schema: dict[str, Any], name: str = "", required: bool = False) -> str:
        """
        Process an object schema and return its Markdown representation.

        :param schema: The object schema
        :param name: Optional name of the object
        :param required: Whether the object is required
        :return: Markdown documentation for the object
        """
        sections: list[str] = []

        if name:
            sections.extend((
                f"{"#" * self.current_heading_level} {name} {"(Required)" if required else "(Optional)"}",
                "",
            ))

        if schema.get("description"):
            sections.extend((schema["description"], ""))

        if "properties" in schema:
            required_props = schema.get("required", [])

            # Create property table header
            sections.extend((
                "| Property | Type | Required | Description |",
                "|----------|------|----------|-------------|",
            ))

            self.current_heading_level += 1

            for prop_name, prop_schema in schema["properties"].items():
                is_required = prop_name in required_props
                type_str = self._get_type_string(prop_schema)
                desc = prop_schema.get("description", "").replace("\n", " ")

                sections.append(f"| {prop_name} | {type_str} | {"Yes" if is_required else "No"} | {desc} |")

                # If the property is an object or array with complex structure, add detailed documentation
                if prop_schema.get("type") in ("object", "array") or any(
                    key in prop_schema for key in ("anyOf", "oneOf", "allOf")
                ):
                    sections.extend(("", self._process_schema(prop_schema, prop_name, is_required)))

            self.current_heading_level -= 1

        return "\n".join(sections)

    def _process_array(self, schema: dict[str, Any], name: str = "", required: bool = False) -> str:
        """
        Process an array schema and return its Markdown representation.

        :param schema: The array schema
        :param name: Optional name of the array
        :param required: Whether the array is required
        :return: Markdown documentation for the array
        """
        sections: list[str] = []

        if name:
            sections.extend((
                f"{"#" * self.current_heading_level} {name} {"(Array, Required)" if required else "(Array, Optional)"}",
                "",
            ))

        if schema.get("description"):
            sections.extend((schema["description"], ""))

        if "items" in schema:
            sections.extend(("Array items:", ""))
            self.current_heading_level += 1
            sections.append(self._process_schema(schema["items"]))
            self.current_heading_level -= 1

        return "\n".join(sections)

    def _process_schema_combination(
        self, schemas: list[dict[str, Any]], combination_type: str, name: str = "", required: bool = False
    ) -> str:
        """
        Process anyOf/oneOf/allOf schema combinations and return their Markdown representation.

        :param schemas: List of schema dictionaries to process
        :param combination_type: Type of combination (anyOf, oneOf, allOf)
        :param name: Optional name of the field
        :param required: Whether the field is required
        :return: Generated Markdown documentation
        """
        sections: list[str] = []
        match combination_type:
            case "anyOf":
                title_suffix = "Any Of"
                description = ("Can be any of the following types:", "")
                item_prefix = "Option"
            case "oneOf":
                title_suffix = "One Of"
                description = ("Must be exactly one of the following types:", "")
                item_prefix = "Option"
            case "allOf":
                title_suffix = "All Of"
                description = ("Must satisfy all of the following:", "")
                item_prefix = "Requirement"
            case _:
                raise ValueError(f"Unknown combination type: {combination_type}")
        if name:
            title = f"{"#" * self.current_heading_level} {name} ({title_suffix})"
            if required:
                title += " (Required)"
            sections.extend((title, ""))
        sections.extend(description)
        self.current_heading_level += 1
        for i, schema in enumerate(schemas, 1):
            sections.extend((f"{item_prefix} {i}:", self._process_schema(schema), ""))
        self.current_heading_level -= 1

        return "\n".join(sections)

    def _process_primitive(self, schema: dict[str, Any], name: str = "", required: bool = False) -> str:
        """
        Process a primitive type schema and return its Markdown representation.

        :param schema: The schema
        :param name: Optional name of the field
        :param required: Whether the field is required
        :return: Generated Markdown documentation
        """
        sections: list[str] = []

        if name:
            title = f"{"#" * self.current_heading_level} {name}"
            if required:
                title += " (Required)"
            sections.extend((title, ""))

        type_str = self._get_type_string(schema)
        sections.append(f"Type: {type_str}")

        if schema.get("description"):
            sections.extend(("", schema["description"]))

        if "enum" in schema:
            sections.extend(("", "Allowed values:"))
            for value in schema["enum"]:
                sections.append(f"- `{value}`")

        if "default" in schema:
            sections.extend(("", f"Default: `{schema["default"]}`"))

        return "\n".join(sections)

    def _get_type_string(self, schema: dict[str, Any]) -> str:
        """
        Get a string representation of the schema type.

        :param schema: The schema
        :return: String representation of the type
        """
        if "type" not in schema:
            return "any"

        type_str = schema["type"]
        if type_str == "array":
            if "items" in schema:
                item_type = self._get_type_string(schema["items"])
                return f"array of {item_type}"
            return "array"

        if type_str == "string" and "format" in schema:
            return f"string ({schema["format"]})"

        return type_str


def dump_markdown_docs(schema: dict[str, Any], output_path: Path | None = None) -> str:
    """
    Generate Markdown documentation from a JSONSchema file.

    :param schema: The JSONSchema
    :param output_path: Optional path to save the generated documentation
    :return: Generated Markdown documentation
    """
    markdown = JsonSchemaMarkdownGenerator().generate_markdown(schema)
    if output_path:
        output_path.write_text(markdown)
    return markdown
