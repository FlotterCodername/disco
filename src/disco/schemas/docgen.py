"""
Copyright Â© 2024 Fabian H. Schneider

This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
If a copy of the MPL was not distributed with this file,
You can obtain one at https://mozilla.org/MPL/2.0/.
"""

__doc__ = """\
Rough version generated by Claude 3.5 Sonnet (New) on 2024-10-27; then manually edited.
"""

from typing import Any

TABLE_HEADER = (
    "| Property | Type | Required | Description |",
    "|----------|:----:|:--------:|-------------|",
)


class JsonSchemaMarkdownGenerator:
    """
    Generates Markdown documentation from a JSONSchema.
    """

    def __init__(self, indent_size: int = 2):
        """
        :param indent_size: Number of spaces to use for indentation
        """
        self.indent_size = indent_size
        self.current_heading_level = 3

    def generate_markdown(self, schema: dict[str, Any]) -> str:
        """
        Generate Markdown documentation from a JSONSchema.

        :param schema: The JSONSchema dictionary
        Returns:
            str: Generated Markdown documentation
        """
        sections: list[str] = []
        if schema.get("description"):
            sections.extend((schema["description"], ""))
        # Process the root schema
        sections.extend(
            (f"{'#' * self.current_heading_level} {schema['title']} top level", *self._process_schema(schema)),
        )
        return "\n".join(i.rstrip() for i in sections).rstrip() + "\n"

    def _process_schema(self, schema: dict[str, Any], name: str = "", required: bool = False) -> list[str]:
        """
        Process a schema object and return its Markdown representation.

        :param schema: The schema
        :param name: Optional name of the schema
        :param required: Whether the schema is required
        :return: Markdown documentation for the schema
        """
        sections: list[str] = []

        # Handle different types of schemas
        match schema:
            case _ if "anyOf" in schema:
                return self._process_schema_combination(schema["anyOf"], "anyOf", name, required)
            case _ if "oneOf" in schema:
                return self._process_schema_combination(schema["oneOf"], "oneOf", name, required)
            case _ if "allOf" in schema:
                return self._process_schema_combination(schema["allOf"], "allOf", name, required)
        if schema.get("type") == "object":
            sections.extend(self._process_object(schema, name, required, is_top=True))
        elif schema.get("type") == "array":
            sections.extend(self._process_array(schema, name, required, is_top=True))
        else:
            sections.extend(self._process_primitive(schema, name, required))

        return sections

    def _process_object(
        self, schema: dict[str, Any], name: str = "", required: bool = False, is_top: bool = False
    ) -> list[str]:
        """
        Process an object schema and return its Markdown representation.

        :param schema: The object schema
        :param name: Optional name of the object
        :param required: Whether the object is required
        :param is_top: Whether the object is the top-level schema
        :return: Markdown documentation for the object
        """
        sections: list[str] = []

        if name:
            sections.extend((
                f"{'#' * self.current_heading_level} `{name}` {self.rq(required)}",
                "",
            ))

        if schema.get("description") and not is_top:
            sections.extend((schema["description"], ""))

        if "properties" in schema:
            required_props = schema.get("required", [])
            sections.extend(TABLE_HEADER)
            self.current_heading_level += 1

            for prop_name, prop_schema in schema["properties"].items():
                is_required = prop_name in required_props
                type_str = self._get_type_string(prop_schema)
                desc = prop_schema.get("description", "").replace("\n", " ")

                sections.append(f"| {prop_name} | {type_str} | {'Yes' if is_required else ''} | {desc} |")

                # If the property is an object or array with complex structure, add detailed documentation
                if prop_schema.get("type") in ("object", "array") or any(
                    key in prop_schema for key in ("anyOf", "oneOf", "allOf")
                ):
                    sections.extend(("", *self._process_schema(prop_schema, prop_name, is_required)))

            self.current_heading_level -= 1

        return sections

    def _process_array(
        self, schema: dict[str, Any], name: str = "", required: bool = False, is_top: bool = False
    ) -> list[str]:
        """
        Process an array schema and return its Markdown representation.

        :param schema: The array schema
        :param name: Optional name of the array
        :param required: Whether the array is required
        :param is_top: Whether the object is the top-level schema
        :return: Markdown documentation for the array
        """
        sections: list[str] = []

        if name:
            sections.extend((
                f"{'#' * self.current_heading_level} `{name}[]` {self.rq(required)}",
                "",
            ))

        if schema.get("description") and not is_top:
            sections.extend((schema["description"], ""))

        if "items" in schema:
            sections.extend(("Array items:", ""))
            self.current_heading_level += 1
            sections.extend(self._process_schema(schema["items"]))
            self.current_heading_level -= 1

        return sections

    def _process_schema_combination(
        self, schemas: list[dict[str, Any]], combination_type: str, name: str = "", required: bool = False
    ) -> list[str]:
        """
        Process anyOf/oneOf/allOf schema combinations and return their Markdown representation.

        :param schemas: List of schema dictionaries to process
        :param combination_type: Type of combination (anyOf, oneOf, allOf)
        :param name: Optional name of the field
        :param required: Whether the field is required
        :return: Generated Markdown documentation
        """
        sections: list[str] = []
        match combination_type:
            case "anyOf":
                title_suffix = "Any Of"
                description = "Can be any of the following types:"
                item_prefix = "Option"
            case "oneOf":
                title_suffix = "One Of"
                description = "Must be exactly one of the following types:"
                item_prefix = "Option"
            case "allOf":
                title_suffix = "All Of"
                description = "Must satisfy all of the following:"
                item_prefix = "Requirement"
            case _:
                raise ValueError(f"Unknown combination type: {combination_type}")
        if not name:
            name = "???"
        sections.extend((
            f"{'#' * self.current_heading_level} `[{name}]` ({title_suffix}) {self.rq(required)}",
            "",
            description,
            "",
        ))
        self.current_heading_level += 1
        for i, schema in enumerate(schemas, 1):
            sections.extend((f"{item_prefix} {i}:", *self._process_schema(schema), ""))
        self.current_heading_level -= 1

        return sections

    def _process_primitive(self, schema: dict[str, Any], name: str = "", required: bool = False) -> list[str]:
        """
        Process a primitive type schema and return its Markdown representation.

        :param schema: The schema
        :param name: Optional name of the field
        :param required: Whether the field is required
        :return: Generated Markdown documentation
        """
        sections: list[str] = []

        if name:
            sections.extend((f"{'#' * self.current_heading_level} {name} {self.rq(required)}", ""))

        type_str = self._get_type_string(schema)
        sections.append(f"Type: {type_str}")

        if schema.get("description"):
            sections.extend(("", schema["description"]))

        if "enum" in schema:
            sections.extend(("", "Allowed values:"))
            for value in schema["enum"]:
                sections.append(f"- `{value}`")

        if "default" in schema:
            sections.extend(("", f"Default: `{schema['default']}`"))

        return sections

    def _get_type_string(self, schema: dict[str, Any]) -> str:
        """
        Get a string representation of the schema type.

        :param schema: The schema
        :return: String representation of the type
        """
        if "type" not in schema:
            return "any"

        type_str = schema["type"]
        if type_str == "array":
            if "items" in schema:
                item_type = self._get_type_string(schema["items"])
                return f"array[{item_type}]"
            return "array"

        if type_str == "string" and "format" in schema:
            return f"string ({schema['format']})"

        return type_str

    @classmethod
    def rq(cls, required: bool) -> str:
        """
        Get a string that indicates whether a field is required or optional.

        :param required: Whether the field is required
        :return: Appropriate string
        """
        return "" if required else "(Optional)"
